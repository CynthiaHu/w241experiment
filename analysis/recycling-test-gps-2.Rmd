---
title: "recycling-test-gps"
author: "Yang"
date: "April 1, 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(data.table)
```


```{r}
# loads data
dt <- data.table(
    rbind(
        read.csv("recycling-data-mont-20180308.csv"),
        read.csv("recycling-data-mont-20180314.csv")
    )
)

# filters out all houses with no recycling bins, this will be our population for the experiment
dtN <- dt[
    BinStatus == "N", 
    .(Number, Street),
]

cat("number of total observations in raw data: ", nrow(dt), "\n")
cat("number of units usable for experiment: ", nrow(dtN))
```

```{r}
# loads gps data
gps <- data.table(read.csv("recycling-data-mont-gps-20180314-yyq.txt", sep="\t"))
```

```{r}
# calculates the cross-join of each house to others
gps1 <- gps[,.(Number, Street, Zip, Long, Lat,j=1),] #adds a dummy column "j" to manipulate the cross join
gpsx <- merge(gps1, gps1, by='j', allow.cartesian=TRUE)
```


```{r}
#calculates the distance between gps points

# R function that computes the "great circle" distance between two gps points. Intended for use with data.table
# https://stackoverflow.com/questions/36817423/how-to-efficiently-calculate-distance-between-pair-of-coordinates-using-data-tab
# r = 
dt.haversine <- function(lat_from, lon_from, lat_to, lon_to, r = 6378137){
    radians <- pi/180
    lat_to <- lat_to * radians
    lat_from <- lat_from * radians
    lon_to <- lon_to * radians
    lon_from <- lon_from * radians
    dLat <- (lat_to - lat_from)
    dLon <- (lon_to - lon_from)
    a <- (sin(dLat/2)^2) + (cos(lat_from) * cos(lat_to)) * (sin(dLon/2)^2)
    return(2 * atan2(sqrt(a), sqrt(1 - a)) * r)
}

# calculates all the distances between all houses
gpsx <- gpsx[ 
    , .(
            Number.x
            ,Street.x
            ,Zip.x
            ,Long.x
            ,Lat.x
            ,Number.y
            ,Street.y
            ,Zip.y
            ,Long.y
            ,Lat.y
            ,dist=dt.haversine( Lat.x, Long.x, Lat.y, Long.y )
        )
    , 
]

```

```{r}
# finds the closest neighbors
gpsx[dist < 50 & dist > 0, 
        .(Number.x
            ,Street.x
            ,Zip.x
            ,Number.y
            ,Street.y
            ,Zip.y
            ,dist)
     , ]
```

```{r}
# finds the fartherest neighbors
gpsx[dist >= 50, 
        .(Number.x
            ,Street.x
            ,Zip.x
            ,Number.y
            ,Street.y
            ,Zip.y
            ,dist)
     , ]

gpsx[dist < 50,.(Number.x,Lat.x,Long.x,Number.y,Lat.y,Long.y,dist),]
```



```{r}
# gets the Bin Status field from the original data set
gpsxb <- merge(
    gpsx
    ,dt[,.(Number,Street,Zip,BinStatus),]
    ,by.x=c("Number.y", "Street.y", "Zip.y")
    ,by.y=c("Number", "Street", "Zip")
)

(gpsxb)
```


```{r}
library(geosphere)
distm(c(39.081434, -77.233082), c(39.082399, -77.230161), fun=distGeo) #326.9657
#distm(c(39.081434, -77.233082), c(39.082399, -77.230161), fun=distHaversine) #326.0298
```